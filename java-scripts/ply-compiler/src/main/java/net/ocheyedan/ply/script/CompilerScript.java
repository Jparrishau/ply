package net.ocheyedan.ply.script;

import net.ocheyedan.ply.FileUtil;
import net.ocheyedan.ply.Output;
import net.ocheyedan.ply.dep.ClassDeps;
import net.ocheyedan.ply.dep.Deps;
import net.ocheyedan.ply.props.*;

import javax.tools.JavaCompiler;
import javax.tools.JavaFileObject;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import java.io.File;
import java.io.IOException;
import java.io.StringWriter;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;

/**
 * User: blangel
 * Date: 9/17/11
 * Time: 8:58 AM
 *
 * Script used to compile source code for the ply build system.
 *
 * This script is dependent upon the {@literal ply-file-changed} script as it uses this information to determine which
 * files to recompile. The property file used to configure this script is {@literal compiler.properties} and so the
 * context is {@literal compiler}.
 * The following properties exist:
 * build.path=string [[default=${project.build.dir}/classes]] (where to place the compiled files)
 * generated.build.path=string [[default=${build.path}]] (the directory where generated source files will be saved.
 *                   sources may be generated by annotation processors).
 * debug=boolean [[default=true]] (true to include debug information in the compiled file)
 * verbose=boolean [[default=false]] (true to print messages from the concrete compiler)
 * optimize=boolean [[default=true]] (true to optimize the compiled code using the concrete compiler's optimization mechanisms)
 * warnings=boolean [[default=true]] (true to show concrete compiler's warning messages)
 * java.source=string [[default=value of {@link System#getProperty(String)} with argument "java.version"]]
 *                    (the -source argument for the java compiler, note only 1.6+ is supported)
 * java.target=string [[default=value of {@link System#getProperty(String)} with argument "java.version"]]
 *                    (the -target argument for the java compiler, note only 1.6+ is supported)
 * java.bootclasspath=string [[default=""]] (used in conjunction with java.target for cross-compilation)
 * java.extdirs=string [[default=""]] (used in conjunction with java.target for cross-compilation)
 * java.debugLevel=string [[default=""]] (comma-separated list of levels to be appended to the '-g' debug switch
 *                    for the java compiler.  Valid levels are 'lines', 'vars', 'source'.  If 'debug' property
 *                    is false, this property is irrelevant.
 * java.warningsLevel=string [[default="" which means all]] (a comma delimited list of warning names (which may be
 *                    prefaced with a '-' to indicate disabling). For a complete list of available names for 1.6 see
 *                    xlint warnings here http://download.oracle.com/javase/6/docs/technotes/tools/solaris/javac.html
 *                    and for 1.7 see http://download.oracle.com/javase/7/docs/technotes/tools/solaris/javac.html#xlintwarnings
 *                    If 'warnings' property is false, this property is irrelevant.
 * java.deprecation=boolean [[default=false]] (true to output deprecation warnings in the java compiler).
 * java.encoding=string [[default="", will result in the platform encoding]] (the source file encoding).
 * java.proc=only|none [[default="", nothing]] (see javac option -proc:)
 * java.processorpath=string [[default=""]] (the path to find processors, see javac option -processorpath)
 * java.processor=string [[default=""]] (a comma delimited list of processors to use, see javac option -processor).
 * compiler=string [[default=java]] (so far only a java concrete compiler is defined, more to come in the future)
 *
 * Note, the source directory is managed by the {@literal project} context, {@literal project[.scope].src.dir}.
 *
 * More detailed descriptions of the javac processor options can be found:
 * 1.6 = http://download.oracle.com/javase/6/docs/technotes/tools/solaris/javac.html
 * 1.7 = http://download.oracle.com/javase/7/docs/technotes/tools/solaris/javac.html
 *
 * TODO
 * - handle multiple source paths
 * - handle cross-compilation (i.e., java.target/java.bootclasspath/java.extdirs
 */
public class CompilerScript {

    /**
     * @param args are either null or contains the scope prepended with '--' as is convention
     */
    public static void main(String[] args) {
        CompilerScript script = new CompilerScript();
        script.invoke();
    }

    private static boolean isSupportedJavaVersion(String version) {
        if (isEmpty(version)) {
            return false;
        }
        try {
            Float javaVersion = Float.valueOf(version);
            if (javaVersion < 1.6f) {
                Output.print("^error^ only JDK 1.6+ is supported for compilation [ running %f ].", javaVersion);
                return false;
            }
        } catch (NumberFormatException nfe) {
            throw new AssertionError(nfe);
        } catch (NullPointerException npe) {
            throw new AssertionError(npe);
        }
        return true;
    }

    private static String getJavaVersion() {
        String version = System.getProperty("java.version");
        // only take the first decimal if multiple
        if ((version.length() > 2) && (version.charAt(1) == '.')) {
            version = version.substring(0, 3);
        }
        return version;
    }

    private static boolean isEmpty(String value) {
        return ((value == null) || value.isEmpty());
    }

    private static boolean getBoolean(String value) {
        return ((value != null) && value.equalsIgnoreCase("true"));
    }

    private final Scope scope;

    private final String srcDir;

    private final Set<String> sourceFilePaths;

    private final File errorsPropertiesFile;

    private final File changedDepsFile;

    private final File defaultScopedCompiledFile;

    private final AtomicReference<String> compilationVerb;

    private CompilerScript() {
        if (!isSupportedJavaVersion(getJavaVersion())) {
            System.exit(1);
        }
        this.scope = Scope.named(Props.get("scope", Context.named("ply")).value());
        String srcDir = Props.get("src.dir", Context.named("project")).value();
        String buildDir = Props.get("build.dir", Context.named("project")).value();
        if ((srcDir.isEmpty()) || (buildDir.isEmpty())) {
            Output.print("^error^ could not determine source or build directory for compilation.");
            System.exit(1);
        }
        this.srcDir = srcDir;
        this.sourceFilePaths = new HashSet<String>();
        Context compilerContext = Context.named("compiler");
        // ensure the build directories are created
        String buildClassesPath = Props.get("build.path", compilerContext).value();
        File buildClassesDir = new File(buildClassesPath);
        buildClassesDir.mkdirs();
        // ensure the generated source directory is created
        String generatedSrcPath = Props.get("generated.src.path", compilerContext).value();
        File generatedSrcDir = new File(generatedSrcPath);
        generatedSrcDir.mkdirs();
        // load the files-to-compile[.scope].properties file from the build directory.
        File filesToCompilePropertiesFile = FileUtil.fromParts(buildDir, "files-to-compile" + scope.getFileSuffix() + ".properties");
        PropFile changedProperties = PropFiles.load(filesToCompilePropertiesFile.getPath(), false, false);
        if (changedProperties == PropFile.Empty) {
            Output.print("^error^ files-to-compile%s.properties not found, please run 'file-changed' before 'compiler'.", scope.getFileSuffix());
        } else {
            for (PropFile.Prop filePath : changedProperties.props()) {
                if (filePath.name.endsWith(".java")) {
                    sourceFilePaths.add(filePath.name);
                }
            }
        }
        this.errorsPropertiesFile = FileUtil.fromParts(buildDir, "compiler-errors" + scope.getFileSuffix() + ".properties");
        this.changedDepsFile = FileUtil.fromParts(buildDir, "changed-deps" + scope.getFileSuffix() + ".properties");
        this.defaultScopedCompiledFile = FileUtil.fromParts(buildDir, "default-scope-compiled.properties");
        this.compilationVerb = new AtomicReference<String>("Compiling");
    }

    private void invoke() {
        cleanupClassFilesForDeletedSourceFiles(); // remove any existing artifacts which no longer have source code
        if (sourceFilePaths.isEmpty()) {
            if (handleExistingErrors()) {
                System.exit(1);
            } else {
                Output.print("Nothing to compile, everything is up to date.");
                return;
            }
        }
        File sourceDir = new File(srcDir);
        String srcPath;
        try {
            srcPath = sourceDir.getCanonicalPath();
            if (!srcPath.endsWith(File.separator)) {
                srcPath = srcPath + File.separator;
            }
        } catch (IOException ioe) {
            throw new AssertionError(ioe);
        }
        FormattedDiagnosticListener diagnosticListener = new FormattedDiagnosticListener(srcPath);
        JavaCompiler javac = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileManager = javac.getStandardFileManager(diagnosticListener, null, null);
        Iterable<? extends JavaFileObject> sourceFiles = fileManager.getJavaFileObjectsFromStrings(sourceFilePaths);
        StringWriter extraPrintStatements = new StringWriter();
        List<String> compilerArguments = getCompilerArgs();
        if (Output.isDebug()) {
            String arguments = getPrettyPrint(compilerArguments);
            Output.print("^dbug^ compiler arguments = %s", arguments);
        }
        JavaCompiler.CompilationTask compilationTask = javac.getTask(extraPrintStatements, fileManager, diagnosticListener,
                                                        compilerArguments, null, sourceFiles);
        Output.print("%s ^b^%d^r^ %ssource file%s for ^b^%s^r^", compilationVerb.get(), sourceFilePaths.size(),
                                                                        Scope.named(Props.get("scope", Context.named("ply")).value()).getPrettyPrint(),
                                                                       (sourceFilePaths.size() == 1 ? "" : "s"),
                                                                       Props.get("name", Context.named("project")).value());
        boolean result = compilationTask.call();
        for (String notes : diagnosticListener.getNotes()) {
            Output.print(notes);
        }
        for (String warning : diagnosticListener.getWarnings()) {
            Output.print(warning);
        }
        for (String error : diagnosticListener.getErrors()) {
            Output.print(error);
        }
        if (extraPrintStatements.getBuffer().length() > 0) {
            Output.print(extraPrintStatements.toString());
        }
        handleFilesWithError(diagnosticListener.getFileErrors(), this.errorsPropertiesFile);
        generateClassDependenciesForSuccessfullyCompiled();
        if (!result) {
            Context compileContext = Context.named("compiler");
            String javaProcessor = Props.get("java.processor", compileContext).value();
            if (!isEmpty(javaProcessor)) {
                Output.print("^warn^ Compilation failed when using annotation processor ^b^%s^r^. Ensure it is accessible [via service discovery or processorpath].", javaProcessor);
            }
            System.exit(1);
        } else {
            if (changedDepsFile.exists()) {
                Output.print("^dbug^ Deleting changed-deps file (^yellow^%s^r^) as compilation succeeded",
                        changedDepsFile.getAbsolutePath());
                changedDepsFile.delete();
            }
            if (!Scope.Default.equals(scope) && "test".equals(scope.name)
                    && defaultScopedCompiledFile.exists()) {
                Output.print("^dbug^ Deleting default-scope-compiled file (^yellow^%s^r^) as test-compilation succeeded",
                        defaultScopedCompiledFile.getAbsolutePath());
                defaultScopedCompiledFile.delete();
            }
        }
    }

    /**
     * Saves all values within {@code errors} into {@code errorsPropertiesFile}.
     * This method will clear {@code errorsPropertiesFile} and if {@code errors} is empty then {@code errorsPropertiesFile}
     * will be deleted.
     * Additionally, for all errors, remove any existing class or class-deps entries.
     * @param errors the set of failed
     * @param errorsPropertiesFile the location of the properties file which manages errors between invocations.
     */
    private void handleFilesWithError(Map<String, Set<String>> errors, File errorsPropertiesFile) {
        if (errors.isEmpty()) {
            if (errorsPropertiesFile.exists()) {
                FileUtil.delete(errorsPropertiesFile);
            }
            return;
        }
        PropFile errorsProperties = new PropFile(Context.named("errors"), PropFile.Loc.Local);

        Context compileContext = Context.named("compiler");
        File buildPath = new File(Props.get("build.path", compileContext).value());
        PropFile.Prop prop = Props.get(Context.named("compiler"), scope).get("class.deps");
        String classDepsDirectory = prop.value();

        for (Map.Entry<String, Set<String>> entry : errors.entrySet()) {
            String failedFile = entry.getKey();
            StringBuilder buffer = new StringBuilder();
            for (String error : entry.getValue()) {
                if (buffer.length() > 0) {
                    buffer.append(" & ");
                }
                buffer.append(error);
            }
            errorsProperties.add(failedFile, buffer.toString());
            // remove any existing class / class-deps file for which we failed to compile
            int index = failedFile.indexOf(srcDir);
            String classSuffix = failedFile.substring(index + srcDir.length()).replace(".java", ".class");
            File classFile = FileUtil.fromParts(buildPath.getAbsolutePath(), classSuffix);
            if (classFile.exists()) {
                Output.print("^dbug^ Deleting existing class file (^yellow^%s^r^) for failed compilation unit", classFile.getAbsolutePath());
                classFile.delete();
            }
            File classDepEntry = FileUtil.fromParts(classDepsDirectory, classSuffix.replace(File.separatorChar, '.').replace(".class", ".properties"));
            if (classDepEntry.exists()) {
                Output.print("^dbug^ Deleting existing class-dependency file (^yellow^%s^r^) for failed compilation unit",
                        classDepEntry.getAbsolutePath());
                classDepEntry.delete();
            }
        }
        PropFiles.store(errorsProperties, errorsPropertiesFile.getPath(), true);
    }

    /**
     * Prints each key within {@link #errorsPropertiesFile}
     * @return true if {@link #errorsPropertiesFile} was not empty
     */
    private boolean handleExistingErrors() {
        PropFile errorsProperties = PropFiles.load(errorsPropertiesFile.getPath(), false, false);
        if (errorsProperties.isEmpty()) {
            return false;
        }
        for (PropFile.Prop error : errorsProperties.props()) {
            Output.print(error.name);
        }
        return true;
    }

    private List<String> getCompilerArgs() {
        List<String> args = new ArrayList<String>();
        Context compileContext = Context.named("compiler");

        args.add("-d");
        args.add(Props.get("build.path", compileContext).value());

        args.add("-s");
        args.add(Props.get("generated.src.path", compileContext).value());

        if (getBoolean(Props.get("optimize", compileContext).value())) {
            args.add("-O");
        }

        if (getBoolean(Props.get("debug", compileContext).value())) {
            String javaDebugLevel = Props.get("java.debugLevel", compileContext).value();
            if (!isEmpty(javaDebugLevel)) {
                args.add("-g:" + javaDebugLevel);
            } else {
                args.add("-g");
            }
        } else {
            args.add("-g:none");
        }

        if (getBoolean(Props.get("verbose", compileContext).value())) {
            args.add( "-verbose" );
        }

        if (getBoolean(Props.get("java.deprecation", compileContext).value())) {
            args.add("-deprecation");
        }

        if (!getBoolean(Props.get("warnings", compileContext).value())) {
            args.add("-Xlint:none");
        } else {
            if (!isEmpty(Props.get("java.warningsLevel", compileContext).value())) {
                String[] tokens = Props.get("java.warningsLevel", compileContext).value().split(" ");
                for (String token : tokens) {
                    args.add("-Xlint:" + token.trim());
                }
            } else {
                args.add("-Xlint");
            }
        }

        String javaProc = Props.get("java.proc", compileContext).value();
        if (!isEmpty(javaProc)) {
            if ("none".equals(javaProc)) {
                Output.print("^dbug^ Ignoring all annotation processing.");
                args.add("-proc:none");
            } else if ("only".equals(javaProc)) {
                Output.print("Option ^b^-proc:only^r^ specified, no source compilation will happen simply annotation processing.");
                compilationVerb.set("Annotation processing");
                args.add("-proc:only");
            } else {
                Output.print("^warn^ Ignoring ^b^java.proc^r^ value ^yellow^%s^r^; expected either ^b^none^r^ or ^b^only^b^", javaProc);
            }
        }
        String javaProcessingPath = Props.get("java.processorpath", compileContext).value();
        if (!isEmpty(javaProcessingPath)) {
            Output.print("^dbug^ Explicitly specifying the annotation processing path as ^b^%s^r^", javaProcessingPath);
            args.add("-processorpath");
            args.add(javaProcessingPath);
        }
        String javaProcessor = Props.get("java.processor", compileContext).value();
        if (!isEmpty(javaProcessor)) {
            Output.print("^dbug^ Explicitly specifying the annotation processing classes as ^b^%s^r^", javaProcessor);
            args.add("-processor");
            args.add(javaProcessor);
        }
        String javaImplicit = Props.get("java.implicit", compileContext).value();
        if (!isEmpty(javaImplicit)) {
            if ("none".equals(javaImplicit)) {
                args.add("-implicit:none");
            } else if ("class".equals(javaImplicit)) {
                args.add("-implicit:class");
            } else {
                Output.print("^warn^ Ignoring ^b^java.implicit^r^ value ^yellow^%s^r^; expected either ^b^none^r^ or ^b^class^b^", javaImplicit);
            }
        }
        List<String> annotationKeys = PrefixedProps.getArguments(compileContext, "java.A", "=");
        for (String annotationKey : annotationKeys) {
            args.add(String.format("-A%s", annotationKey));
        }

        args.add("-source");
        String javaSource = Props.get("java.source", compileContext).value();
        if (isSupportedJavaVersion(javaSource)) {
            args.add(javaSource);
        } else {
            args.add(getJavaVersion());
        }
        args.add("-target");
        String javaTarget = Props.get("java.target", compileContext).value();
        if (isSupportedJavaVersion(javaTarget)) {
            args.add(javaTarget);
        } else {
            args.add(getJavaVersion());
        }

        String javaEncoding = Props.get("java.encoding", compileContext).value();
        if (!isEmpty(javaEncoding)) {
            args.add("-encoding");
            args.add(javaEncoding);
        }

        // add supplemental arguments if any
        List<String> supplementalArgs = PrefixedProps.getArguments(compileContext, "args");
        for (String supplemental : supplementalArgs) {
            args.add(supplemental);
        }

        args.add("-classpath");
        args.add(createClasspath(Props.get("build.path", compileContext).value(), Deps.getResolvedProperties(false)));

        args.add("-sourcepath");
        args.add(srcDir);

        return args;
    }

    private void cleanupClassFilesForDeletedSourceFiles() {
        Context compileContext = Context.named("compiler");
        File directory = new File(Props.get("build.path", compileContext).value());
        if (!directory.exists()) {
            return;
        }
        PropFile.Prop prop = Props.get(Context.named("compiler"), scope).get("class.deps");
        String classDepsDirectory = prop.value();
        cleanupDeletedFiles(directory, directory.getAbsolutePath(), classDepsDirectory);
    }

    private void generateClassDependenciesForSuccessfullyCompiled() {
        Context compileContext = Context.named("compiler");
        File buildPath = new File(Props.get("build.path", compileContext).value());
        Set<String> classes = new HashSet<String>();
        for (String srcFile : sourceFilePaths) {
            // find the corresponding class file associated with the source file
            int index = srcFile.indexOf(srcDir);
            String sourceName = srcFile.substring(index + srcDir.length());
            File classFile = FileUtil.fromParts(buildPath.getAbsolutePath(), sourceName.replace(".java", ".class"));
            if (classFile.exists()) {
                classes.add(classFile.getAbsolutePath());
            }
        }
        ClassDeps classDeps = new ClassDeps();
        classDeps.processClassDependencies(buildPath.getAbsolutePath(), classes);
    }

    private void cleanupDeletedFiles(File directory, String buildDir, String classDepsDirectory) {
        File[] entries = directory.listFiles();
        if (entries == null) {
            return;
        }
        for (File entry : entries) {
            if (entry.isDirectory()) {
                cleanupDeletedFiles(entry, buildDir, classDepsDirectory);
                continue;
            }
            // get corresponding source directory
            String className = entry.getAbsolutePath().substring(buildDir.length());
            String withoutBuildAsJava = className.replace(".class", ".java");
            if (withoutBuildAsJava.contains("$")) {
                continue; // inner classes don't have source files themselves
            }
            File sourceFile = FileUtil.fromParts(srcDir, withoutBuildAsJava);
            if (!sourceFile.exists()) {
                Output.print("^dbug^ Deleting existing class file (^yellow^%s^r^) for removed source file", entry.getAbsolutePath());
                entry.delete();
                File classDepEntry = FileUtil.fromParts(classDepsDirectory, className.replace(File.separatorChar, '.').replace(".class", ".properties"));
                if (classDepEntry.exists()) {
                    Output.print("^dbug^ Deleting existing class-dependency file (^yellow^%s^r^) for removed source file", classDepEntry.getAbsolutePath());
                    classDepEntry.delete();
                }
            }
        }
    }

    /**
     * Any property starting with {@code propertyPrefix} will be stripped of the prefix and added to the return list
     * If the value of the property is present it will be appended to the stripped property name.
     * E.g. Assuming {@code propertyPrefix} is "args" and the {@code context} is "compiler"
     * then the command "ply set argsfoo='=bar' in compiler" will result
     * in the following argument "foo=bar"
     * @param context the context
     * @param propertyPrefix the property prefix to match
     * @return the matched properties
     */
    private static List<String> getArguments(Context context, String propertyPrefix) {
        List<String> arguments = new ArrayList<String>(1);
        PropFileChain chain = Props.get(context);
        for (PropFile.Prop prop : chain.props()) {
            if (prop.name.startsWith(propertyPrefix) && (prop.name.length() > propertyPrefix.length())) {
                String keyName = prop.name.substring(6);
                String keyValue = prop.value();
                arguments.add(String.format("%s%s", keyName, (isEmpty(keyValue) ? "" : keyValue)));
            }
        }
        return arguments;
    }

    /**
     * @param arguments to form into a string
     * @return {@code arguments} separated by a space character
     */
    private static String getPrettyPrint(List<String> arguments) {
        StringBuilder buffer = new StringBuilder();
        for (String argument : arguments) {
            buffer.append(argument);
            buffer.append(" ");
        }
        return buffer.toString().trim();
    }

    /**
     * Concatenates together {@code localPath} with the keys of {@code dependencies} (if any), separating each
     * by the {@link File#pathSeparator}.
     * @param localPath of the classpath
     * @param dependencies of the project, if any
     * @return the concatenated classpath
     */
    private static String createClasspath(String localPath, PropFile dependencies) {
        StringBuilder buffer = new StringBuilder(localPath);
        for (PropFile.Prop dependency : dependencies.props()) {
            buffer.append(File.pathSeparator);
            buffer.append(dependency.value());
        }
        return buffer.toString();
    }

}